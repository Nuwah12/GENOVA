#' Get a z-stack matrix of 2D-regions (e.g. loops).
#'
#' Extract matrices around a defined set of pixels, like possible loops.
#' Sums over all matrices to produce a single Z-stack matrix, which is normalised to 100 loops.
#'
#' @param experiment The Hi-C experiment object of a sample: produced by construct.experiment().
#' @param loop.bed Bedpe file containing the loop positions: produced by read.bedpe().
#' @param smallTreshold The minimal size of loops. Too small loops lead to messy plots.
#' @param verbose Produces a progress-indication.
#' @return A tidy data.frame containing the Z-stack scores.
#' @import data.table
#' @export
APA <- function(experiment, loop.bed, smallTreshold = 225e3, verbose = F, saveRaw = F, ...){
  if(saveRaw){
    rawMatList = list()
  }
  hicdata <- experiment$ICE
  bed <- experiment$ABS
  resolution <- experiment$RES
  # Check for setkey
  if(is.null(data.table::key(hicdata))){data.table::setkey(hicdata, V1, V2)}
  # Make chr:pos index of HiC-index
  bed.p <- paste0(bed[,1], ":", bed[,2])
  # Remove smaller loops
  loop.bed <- loop.bed[abs(loop.bed[,6]-loop.bed[,2]) >= smallTreshold ,]
  # Is BED 1 upstream of BED2?
  #Elzo maybe do something like this
  loop.bed[loop.bed[,2] > loop.bed[,5],] <- loop.bed[loop.bed[,2] > loop.bed[,5],c(4,5,6,1,2,3)]
  
  for(i in 1:length(loop.bed[,1])){
    if( loop.bed[i,2] > loop.bed[i,5]){
      loop.bed <- loop.bed[i,c(4,5,6,1,2,3)]
    }
  }
  # Prune NA-rows
  #Elzo comma before 1:6
  loop.bed <- na.exclude(loop.bed[,1:6])
  #loop.bed <- na.exclude(loop.bed[1:6])
  # Get start positions of the loop, floored to 10kb windows, and make chr:pos index
  loop.bed1.p <- paste0(loop.bed[,1], ":", as.integer(resolution*floor(  ( (abs( loop.bed[,3] - loop.bed[,2] ) /2 )+ loop.bed[,2])   /resolution)))
  loop.bed2.p <- paste0(loop.bed[,4], ":", as.integer(resolution*floor(  ( (abs( loop.bed[,6] - loop.bed[,5] )/2)  + loop.bed[,5])   /resolution)))
  
  #Elzo why not the following
  #just average start and end (middle), divide by the resolution, floor and multiply by the resolution
  # loop.bed1.p <- paste0(loop.bed[,1], ":", resolution*floor( ( (loop.bed[,2]+loop.bed[,3])/2)/resolution) )
  # loop.bed2.p <- paste0(loop.bed[,4], ":", resolution*floor( ( (loop.bed[,5]+loop.bed[,6])/2)/resolution) )
  
  # Bugfix: in some cases paste0 yields an extra whitespace
  loop.bed1.p <- gsub(" ", "", loop.bed1.p, fixed = TRUE)
  loop.bed2.p <- gsub(" ", "", loop.bed2.p, fixed = TRUE)
  # Check if loops are all found:
  if(!all(loop.bed1.p %in% bed.p)){
    if(!all(loop.bed2.p %in% bed.p) ){
      stop('not all loop-anchors can not be found in HiC-file.\n# Are you sure that both are from the same complete reference?')
    }
    else{
      stop(paste0(table(foo %in% bar)[1],' upstream loop-anchors can not be found in HiC-file.\n# Are you sure that both are from the same complete reference?'))}
  }else{
    if(!all(loop.bed2.p %in% bed.p) ){
      stop(paste0(table(foo %in% bar)[1],' downstream loop-anchors can not be found in HiC-file.\n# Are you sure that both are from the same complete reference?'))
    }
  }
  # Get anchor HiC-indexes
  x.pos <- bed[match(loop.bed1.p,bed.p),4]
  y.pos <- bed[match(loop.bed2.p,bed.p),4]
  # Initialise matrix
  score.matrix <- matrix(0, ncol=21, nrow=21)
  # Loop trough loops and sum over scorematrices
  lx <- length(x.pos)
  for( i in 1:lx){
    if(verbose){cat(paste0(i, ' of ', lx, ' loops.'), "\r")}
    # Get Indeces of 10 up/downstream of anchor
    sel.x <- (x.pos[i]-10):(x.pos[i]+10)
    sel.y <- (y.pos[i]-10):(y.pos[i]+10)
    # Exract scores from HiC
    s <- select.sub.2D(hicdata, sel.x,sel.y)
    s$V1 <- (s$V1 - min(sel.x)) + 1
    s$V2 <- (s$V2 - min(sel.y)) + 1
    # Check for 21x21 mat:
    if(length(unique(s$V2)) < 21){
      cols <- 1:21
      toADD <- cols[!cols %in% unique(s$V2)]
      newdf <- data.frame(unique(cbind(rep(1:21, each = 21), rep(toADD, length = 21),0)))
      colnames(newdf) <- c("V1","V2","V3")
      s <- rbind(s, newdf)
    }
    if(length(unique(s$V1)) < 21){
      cols <- 1:21
      toADD <- cols[!cols %in% unique(s$V1)]
      newdf <- data.frame(unique(cbind(rep(toADD, length = 21),rep(1:21, each = 21),0)))
      colnames(newdf) <- c("V1","V2","V3")
      s <- rbind(s, newdf)
    }
    # Make matrix
    # Fastest way!
    s.mat <- reshape2::acast(s, V1~V2, value.var="V3")

    # # Old way
    # s.mat <- matrix(nrow=21, ncol=21,
    #                 dimnames=list(1:21, 1:21))
    # s.mat[cbind(s$V1, s$V2)] <- s$V3
    s.mat[is.na(s.mat)] <- 0
    # Add to Z-stack
    score.matrix <- score.matrix + s.mat
    # Add to rawMatList
    if(saveRaw){
      rawMatList[[i]] <- s.mat
    }
  } 
  # Normalise to 100 loops
  #Elzo you tested for the fact that all the loop.bed1.p are in bed.p right?
  #why the match, cant you do.
  norma_loopCounts <- (score.matrix/length(loop.bed1.p)) * 100
  #Elzo I find the normalization to 100 loops a bit strange
  #norma_loopCounts <- (score.matrix/as.numeric(unname(table(loop.bed1.p %in% bed.p)) ) ) * 100
  # Rotate 90CW, so that diagonal of HiC-matrix is in bottomleft
  norma_loopCounts <- t(apply(norma_loopCounts, 2, rev))
  colnames(norma_loopCounts) <- 1:21
  if(saveRaw){
    return(list(APA = norma_loopCounts, rawMatList = rawMatList))
  } else {
  return(norma_loopCounts)
  }
}

#' Construct a HiC-experiment.
#'
#' Make a structure which holds the most needed information of a HiC-experiment.
#'
#' @param ICEDpath Full path to HiC-pro matrix-file.
#' @param BEDpath Full path the HiC-pro index-file
#' @param SAMPLENAME The name of the sample.
#' @param COLOR Color associated with sample.
#' @param COMMENTS A place to store some comments.
#' @return A list.
#' @export
construct.experiment <- function(ICEDpath,BEDpath, SAMPLENAME, COLOR = 1, COMMENTS = NULL){
  # Check if files exist
  if(!file.exists(ICEDpath)){stop('ICE-matrix file not found.')}
  if(!file.exists(BEDpath)){stop('ICE-index file not found.')}
  
  ICE <- read.hicpro.matrix(ICEDpath)
  ABS <- data.table::fread(BEDpath, header = F, data.table = F)
  chromVector <- as.character(unique(ABS$V1))
  res = as.numeric( median(ABS$V3-ABS$V2)  )
  
  # Contruct list
  list(
    # Iced HiC-matrix in three-column format (i.e. from HiC-pro)
    ICE = ICE,
    
    # HiC-index in four-column format (i.e. from HiC-pro)
    ABS = ABS,
    
    # Name of sample
    NAME = SAMPLENAME,
    
    # Resolution of sample
    RES = res,
    
    # Available chromosomes
    CHRS = chromVector,
    
    # Color of sample (optional, but recommended for running RCP)
    COL = COLOR,
    
    # Comments
    COMM = COMMENTS
    
  )
}

#' Read hicpro three column matrix format.
#'
#' This function loads a HiC-pro file as a matrix. It assumes a three-column
#' layout: bin1, bin2 and score. All scors are normalised to contacts per *norm*
#' total contacts.
#'
#' @param file Full path to file.
#' @param norm Normalising factor.
#' @return A data.table with normalised counts.
#' @export
read.hicpro.matrix <- function(file, norm=100e6){
  data <- data.table::fread(file)
  data.table::setkey(data, "V1", "V2")
  data$V3 <- norm*data$V3/sum(data$V3)
  return(data)}

select.sub.2D <- function( data , X, Y ){
  x <- rep(X[1]:X[length(X)], X[length(X)]-X[1]+1)
  y <- rep(Y[1]:Y[length(Y)], each=length(Y[1]:Y[length(Y)]))
  data.sub <- data[base::list(x,y)]
  data.sub <- data.sub[!is.na(data.sub$V3)]
  data.sub
}

TADbedpeToGranges <- function(inpath, ...){
  infile <- read.delim(inpath, header=FALSE)
  vijf <- infile[,c(1,2,2)]
  drie <- infile[,c(1,3,3)]
  if(!any(grepl(infile$V1, pattern =  "chr") )){
    vijf[,1 ] <- gsub(vijf[,1], pattern = "^", replacement = "chr")
    drie[,1 ] <- gsub(drie[,1], pattern = "^", replacement = "chr")
  }
  colnames(vijf) <- c("seqnames", "start", "end")
  colnames(drie) <- c("seqnames", "start", "end")
  vijf <- na.exclude(vijf)
  drie <- na.exclude(drie)
  # check if 5 is smaller than 3
  for(i in 1:nrow(drie)){
    if(drie[i,2] < vijf[i,2]){
      dd <- drie[i,]
      vv <- vijf[i,]
      drie[i,] <- vv
      vijf[i,] <- dd
    }
  }
  grV <- GenomicRanges::makeGRangesFromDataFrame(vijf)
  grD <- GenomicRanges::makeGRangesFromDataFrame(drie)
  
  return(list(fivePrime = grV,threePrime = grD))
}

loopToGranges <- function(inpath, HICCUPS = T,...){
  if(HICCUPS){
    infile <- read.delim(inpath, header=TRUE)
  } else {
    infile <- read.delim(inpath, header=FALSE)
  }
  vijf <- infile[,1:3]
  drie <- infile[,4:6]
  if(!any(grepl(infile$V1, pattern =  "chr") )){
    vijf[,1 ] <- gsub(vijf[,1], pattern = "^", replacement = "chr")
    drie[,1 ] <- gsub(drie[,1], pattern = "^", replacement = "chr")
  }
  colnames(vijf) <- c("seqnames", "start", "end")
  colnames(drie) <- c("seqnames", "start", "end")
  vijf <- na.exclude(vijf)
  drie <- na.exclude(drie)
  for(i in 1:nrow(vijf)){
    if(vijf[i,3] < vijf[i,2]){
      d <- vijf[i,3]
      vijf[i,3] <- vijf[i,2]
      vijf[i,2] <- d
    }
  }
  for(i in 1:nrow(drie)){
    if(drie[i,3] < drie[i,2]){
      d <- drie[i,3]
      drie[i,3] <- drie[i,2]
      drie[i,2] <- d
    }
  }
  # check if 5 is smaller than 3
  for(i in 1:nrow(drie)){
    if(drie[i,2] < vijf[i,2]){
      dd <- drie[i,]
      vv <- vijf[i,]
      drie[i,] <- vv
      vijf[i,] <- dd
    }
  }
  grV <- GenomicRanges::makeGRangesFromDataFrame(vijf)
  grD <- GenomicRanges::makeGRangesFromDataFrame(drie)
  
  return(list(fivePrime = grV,threePrime = grD))
}

addSlopToGR <- function(inGR, fiveSlop = 20e3, threeSlop = 20e3){
  df <- as.data.frame(inGR)
  df[,2] <- df[,2] - fiveSlop
  df[,3] <- df[,3] + threeSlop
  return(makeGRangesFromDataFrame(df))
}

#' A quick lookup of square region from a HiC matrix.
#'
#' Extracts a symmetric matrix around the diagonal from *start* to *stop*.
#'
#' @param data HiC-pro matrix
#' @param start Start of index-range.
#' @param end End of index-range.
#' @return A data.table with normalised counts.
#' @export
select.sub <- function( data, start, end ){
  x <- rep(start:end, end-start+1)
  y <- rep(start:end, each=end-start+1)
  data.sub <- data[list(x,y)]
  data.sub <- data.sub[!is.na(data.sub$V3)]
  return(data.sub)
}

#' Plot the APA-results
#'
#' @param APAlist A list of results from `APA`.
#' @param title Text to plot
#' @param Focus Wich sample does need to be the to-compare sample?
#' @return A grid object, containing two ggplot-objects.
#' @export
visualise.APA.ggplot <- function(APAlist, title, focus = 1){
  # Make two dataframes
  abovePlots <- data.frame(Var1 = integer(),
                           Var2 = integer(),
                           value = numeric(),
                           sample = factor())
  belowPlots <- abovePlots
  # Loop trough list and melt
  list.len <- length(APAlist)
  belownames <- vector()
  for(i in 1:list.len){
    a <- reshape2::melt(APAlist[[i]])
    a$sample <- factor(rep(names(APAlist)[i], length(a[,1])))
    abovePlots <- rbind(abovePlots, a)
    
    e <- reshape2::melt(APAlist[[i]]-APAlist[[focus]])
    e$sample <- rep(paste0(names(APAlist)[focus], ' vs ', names(APAlist)[i] ) , length(e[,1]))
    belowPlots <- rbind(belowPlots, e)
    belownames <- c(belownames, paste0(names(APAlist)[focus], ' vs ', names(APAlist)[i] ))
  }
  # Find best color-limits
  z <- max( abs( c(  quantile(na.exclude(abovePlots$value), .01) , quantile(na.exclude(abovePlots$value), .99)        )  )   )
  abovePlots$value[abovePlots$value > z] <- z
  abovePlots$value[abovePlots$value < (z *-1)] <- (z *-1)
  # Set focus-sample to column 1
  abovePlots$sample <- factor(abovePlots$sample, levels = c(levels(abovePlots$sample)[focus], levels(abovePlots$sample)[!levels(abovePlots$sample) %in% levels(abovePlots$sample)[focus]] ))
  volgorde <- match(names(APAlist),levels(abovePlots$sample))
  belowPlots$sample <- factor(belowPlots$sample, levels = belownames[volgorde] )
  # Plot per sample
  plot1 <- ggplot2::ggplot(abovePlots, ggplot2::aes(Var1, Var2)) + ggplot2::geom_raster(ggplot2::aes(fill = value)) + ggplot2::facet_grid(.~ sample) +
    ggplot2::coord_fixed() + ggplot2::theme(panel.background = ggplot2::element_rect(fill = "#FAFAFA",colour = NA)) +
    ggplot2::scale_x_continuous(breaks = c(5.5,11,16.5), labels = c("-50Kb", "3'", "+50Kb")) +
    ggplot2::scale_y_continuous(breaks = c(5.5,11,16.5), labels = c("-50Kb", "5'", "+50Kb")) +
    ggplot2::labs(title = title,x = "", y = "", fill = "Contacts ") +
    ggplot2::scale_fill_distiller(limits = c(0, z), palette = "Spectral")
  # Find best color-limits
  z2 <- max( abs( c(  quantile(na.exclude(belowPlots$value), .01) , quantile(na.exclude(belowPlots$value), .99)        )  )   )
  belowPlots$value[belowPlots$value > z2] <- z2
  belowPlots$value[belowPlots$value < (z2 *-1)] <- (z2 *-1)
  # Plot difference-plots
  plot2 <- ggplot2::ggplot(belowPlots, ggplot2::aes(Var1, Var2)) +
    ggplot2::geom_raster(ggplot2::aes(fill = value)) + ggplot2::facet_grid(.~ sample) + ggplot2::coord_fixed()  +
    ggplot2::scale_fill_gradient2(limits = c(z2*-1,z2), midpoint=0, low="#2166ac", mid="white", high="#b2182b") +
    ggplot2::theme(panel.background = ggplot2::element_rect(fill = "#FAFAFA",colour = NA))+
    ggplot2::scale_x_continuous(breaks = c(5.5,11,16.5), labels = c("-50Kb", "3'", "+50Kb"))+
    ggplot2::scale_y_continuous(breaks = c(5.5,11,16.5), labels = c("-50Kb", "5'", "+50Kb")) +
    ggplot2::labs(x = "", y = "", fill = "Difference")
  return(grid.arrange(plot1, plot2, ncol=1))
  #grid::grid.newpage()
  #grid::grid.draw(rbind(grid::ggplotGrob(plot1), grid::ggplotGrob(plot2), size = "last"))
}
