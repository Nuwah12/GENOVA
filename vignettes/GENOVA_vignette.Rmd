---
title: "GENOVA: explore the Hi-C's"
author:
- name: Robin H. van der Weide
  affiliation:
  - Division of Gene Regulation, the Netherlands Cancer Institute
- name: Elzo de Wit
  affiliation: Division of Gene Regulation, the Netherlands Cancer Institute
  email: e.d.wit@nki.nl
date: "`r Sys.Date()`"
output:
  BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{GENOVA: explore the Hi-C's}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

bibliography: GENOVA.bib
---
# Loading data

```{r, echo=T, warning=FALSE, error=F, results='hide'}
library(GENOVA)
```


## Index-based
GENOVA expects two input files: the signal- and the index-file. Signal-files have three columns (bin1, bin2, contactCount) and index-files have four (chromosome, start, end, bin). These are the default output of the Hi-C mapping pipeline HiC-Pro [@Servant2015], where they are called \*.matrix and \*.bed. The files are expected to be genome-wide and may be corrected with ICE-normalisation.

## Juicebox
We added a convenience script **juicerToGENOVA.py**, to load files from Juicerbox (.hic files). This allows for a fast conversion to signal- and index-files from, for example, data from Sanborn et al.[-@Sanborn2015]:

```{r J2G, eval=FALSE, highlight=FALSE}
# Convert data from Sanborn et al. normalised at 10kb resoltion:
juicerToGenova.py -C ucsc.hg19_onlyRealChromosomes.noChr.chromSizes \
-JT ~/bin/juicer/AWS/scripts/juicebox_tools.7.0.jar \
-H ~/Downloads/Sanborn_Hap1_combined_30.hic \
-R 10000 \
-force TRUE \
-norm KR \
-O Sanborn_Hap1_combined_30.hic_10kb_KR 
```

## Recommended resolutions
To ensure computational strain and time is kept to a minimum, we recommend different resolutions for different functions. More experienced users are free to deviate, while keeping in mind that these datasets are quite memory-heavy. 

Function   | Resolution
---------- | ----------
APA | 10kb-20kb
ATA  | 10kb-40kb
cisTotal.perChrom | 500kb-1Mb
chromosomeMatrix | 500kb-1Mb
RCP | 40kb-500kb
intra.inter.TAD.contacts | 20kb - 40kb 
PE-SCAn | 20kb-40kb
hic.matrixplot | $\frac{width\ in\ bp\ of\ window}{500}$ 
: (\#tab:table) Recommended resolutions. These will provide optimal resource/result tradeoffs.

## construct.experiment
Every Hi-C experiment will be stored in an experiment-object. This is done by invoking the `construct.experiment` function. Inside, several sanity checks will be performed and the data is normalised to the total sum of reads. You can also add centromere-information in the form of a three-column data.frame:
```{r centromere, cache=T}
# Please make sure that the chromosome-names match.
centromeres = read.delim('data/hg19_cytobandAcen.bed', 
                         sep = '\t', 
                         h = F, 
                         stringsAsFactors = F)

head(centromeres)
```

For this example, we are going to use the Hi-C maps of WT and $\Delta$WAPL Hap1 cells from Haarhuis et al. [-@Haarhuis2017]. Since the genome-wide analyses do not need very high-resolution data, we will construct both 10kb, 40kb and 1Mb resolution experiment-objects. 
```{r CONSTRUCT, echo=T, warning=FALSE, error=F, results='hide', cache=T, cache.lazy=F}
Hap1_WT_10kb <- construct.experiment(
                                signalPath = 'data/WT_10000_iced.matrix', 
                                indicesPath = 'data/WT_10000_abs.bed', 
                                name = "WT",
                                centromeres = centromeres,
                                color = "black", 
                                comments = "This is an optional memo-field.")

Hap1_WAPL_10kb <- construct.experiment(
                                signalPath = 'data/WAPL_10000_iced.matrix', 
                                indicesPath = 'data/WAPL_10000_abs.bed', 
                                name = "WAPL",
                                centromeres = centromeres,
                                color = "red")

Hap1_WT_40kb <- construct.experiment(
                                signalPath = 'data/WT_40000_iced.matrix', 
                                indicesPath = 'data/WT_40000_abs.bed', 
                                name = "WT",
                                centromeres = centromeres,
                                color = "black", 
                                comments = "This is an optional memo-field.")

Hap1_WAPL_40kb <- construct.experiment(
                                signalPath = 'data/WAPL_40000_iced.matrix', 
                                indicesPath = 'data/WAPL_40000_abs.bed', 
                                name = "WAPL",
                                centromeres = centromeres,
                                color = "red")

Hap1_WT_1MB <- construct.experiment(
                                signalPath = 'data/WT_1000000_iced.matrix', 
                                indicesPath = 'data/WT_1000000_abs.bed', 
                                name = "WT",
                                centromeres = centromeres,
                                color = "black", 
                                comments = "This is an optional memo-field.")

Hap1_WAPL_1MB <- construct.experiment(
                                signalPath = 'data/WAPL_1000000_iced.matrix', 
                                indicesPath = 'data/WAPL_1000000_abs.bed', 
                                name = "WAPL",
                                centromeres = centromeres,
                                color = "red")

```

In this object are several slots:
```{r peakEXP3, collapse=F, results='markup', echo = F}
str(Hap1_WT_40kb, width = 60,   vec.len=1, strict.width = 'wrap')
```

# Genome-wide analyses
## Cis-quantification
Another important quality-metric is the fraction of *cis*-interactions. Work by the group of Amons Tanay showed that the expected amount of intra-chromosomal contacts is 90-93% [@Olivares-Chauvet2016]. Assuming that any extra inter-chromosomal contacts are due to dubris/noise, the user might aspire to get the *cis*-percentages as close to 90% as possible.
```{r cis, cache=T,fig.cap="Fraction of cis-contacts per chromosome.", fig.small = T}
cisChrom_out <- cisTotal.perChrom(Hap1_WT_1MB)
```

Of course, one can also inspect the results per chromosome more closely:
```{r cis2, cache=T,fig.cap="Fraction of cis-contacts per chromosome. Chromosomes 9, 15, 19 \\& 22 have translocations, which leads to the appearance of more trans-interactions than similar-sized chromosomes."}
plot(cisChrom_out$perChrom, las=2)
abline(h = cisChrom_out$genomeWide) # genome-wide percentage
```

## chromosome plots
To find possible translocations and/or flawed mapping, we can plot the genome-wide enrichment of interactions between all combinations of chromosomes. The values in the matrix are $log10(observed/expected)$.
```{r chromMat, message=FALSE, cache=T, fig.cap="Chromosome matrix. The two known translocations of Hap1 cells are easily seen (15-19 \\& 9-22)."}
par(pty ='s')
# Lets remove mitochondrial and Y-chromosomal contacts
chromosomeMatrix(Hap1_WT_1MB, remove = c("chrM","chrY"))
```

## RCP
The Relative Contact Probability computes the contact probability as a function of genomic distance, as described in [@Lieberman-Aiden2009]. This can be computed for a specific set of chromosomes or genome-wide. To be able to ignore centromeric contacts (which have a abberant RCP), centromeric information is need. This is taken from the experiment-object or found emperically by comparing trans-interactions.

```{r doRCP, cache=T}
RCP_out <- RCP(experimentList = list(Hap1_WT_40kb, Hap1_WAPL_40kb), 
               chromsToUse = c('chr1','chr2','chr3'))
```

The user can decide to plot the RCP per chromosome. If the data is sparse, a LOESS-smooting could be convenient. It takes the color and name from the experiment-objects. 
```{r RCPPLOT1, message=FALSE, fig.wide= T , cache=T,  fig.cap= "RCP. Every facet shows the RCP of one chromosome."}
# Plot RCP: combined
visualise.RCP.ggplot(RCPdata = RCP_out, 
                     smooth = T, # use a LOESS smoothing
                     combine = F) # Don't merge data from all chromosomes
```

It is also possible to combine all available data into a genome-wide RCP-plot.
```{r RCPPLOT2, message=FALSE,   fig.small= T , fig.cap= "RCP. All data combined in one plot.",cache=T}
# Plot RCP: per-chromosome
visualise.RCP.ggplot(RCPdata = RCP_out, 
                     smooth = T, # use a LOESS smoothing
                     combine = T) # Merge data from all chromosomes
```


## matrix plots
To produce richly annotated zoomed-in (i.e. max 10Mb) plots of specific regions, we use the `hic.matrixplot` function. In this, we can use one or two experiment objects: two can be shown either in diff-mode (the difference between the two) or upper/lower triangle mode. TAD- and loop-annotations can be added, as well as bigwig- and bed-tracks. Moreover, genemodel-files can be added.
```{r HMP1, message=FALSE , fig.asp=1,fig.cap= "Hi-C matrixplot. Simplest example: one experiment, no annotation",dev = 'png', dpi=300,cache=T, fig.retina=T, fig.small = F}
par(pty="s")
# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               chrom = 'chr7',
               start = 25e6,
               end=30e6, 
               cut.off = 50) # upper limit of contacts
```

### two experiments
Adding a second experiment will give us the option of `coplot`, which can be `dual` or `diff`. The first shows exp1 in the lower triangle and exp2 in the upper. Exp1 is subtracked from exp2 in `diff`-mode: red is therefore more contacts in exp2 and blue denotes more contacts in exp1.
```{r HMPdiff1, message=FALSE , fig.asp=1,fig.cap= "Hi-C matrixplot: dual. The extended loops in the WAPL knockout are easily seen at around 28Mb in the upper triangle.",cache=T, fig.retina=T, dev = 'png', dpi=300,fig.small = F}
par(pty="s")
# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               exp2 = Hap1_WAPL_10kb,
               coplot = 'dual',
               chrom = 'chr7',
               start = 25e6,
               end=30e6, 
               cut.off = 50) # upper limit of contacts
```

```{r HMPdiff2, message=FALSE , fig.cap= "Hi-C matrixplot: diff. Note the ease of identifying the extended loops.",dev = 'png', dpi=300,cache=T,fig.asp=1, fig.small = F, fig.retina=T}
par(pty="s")
# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               exp2 = Hap1_WAPL_10kb,
               coplot = 'diff',
               chrom = 'chr7',
               start = 25e6,
               end=30e6, 
               cut.off = 25) # upper limit of contacts
```

### TADs and loops

Lets load some TAD- and loop-annotations:
```{r loadLOOP_mp, cache=T}
WT_TADs = read.delim('data/WT_hicseg_TADs.bed', h = F)
WT_Loops = read.delim('data/WT_HICCUPS.bedpe', h = F, skip = 1)
```

```{r fixLOOP_mp, echo = F, cache=T}
WT_Loops$V1 = gsub(pattern = "^", replacement = "chr", x = WT_Loops$V1) 
WT_Loops$V4 = gsub(pattern = "^", replacement = "chr", x = WT_Loops$V4)
```

Add them to the plot by using the `tad`- and `loops`-arguments. Both can be plotted in one or both of the traingles and colored as whished. Since loops are very small in a hic-matrixplot, they will be fully overlapped by the loop-annotations. To overcome this, we expand the annotations with a fixed bp using `loops.resize`. This will lead to a more box-like annotation surrounding the loop.
```{r HMPtadloop, message=FALSE , fig.cap= "Hi-C matrixplot: TAD- and loop-annotations.",cache=T,fig.asp=1, dev = 'png', dpi=300,fig.small = F}
par(pty="s")
# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               chrom = 'chr7',
               start = 25e6,
               end=30e6, 
               loops = WT_Loops, # see APA
               loops.color = '#998ec3', # purple loops
               loops.type = 'upper', # only plot in upper triangle
               loops.resize = 20e3, # expand for visibility
               tads = WT_TADs, # see ATA
               tad.type = 'lower', # only plot in lower triangle
               tads.color = '#91cf60', # green TAD-borders
               cut.off = 25) # upper limit of contacts
```

### BigWigs and BEDs
Two tracks above and two tracks to the left can be added. These can be either BED-like data.frames or the paths the .bw files. For example, lets load a BED6-file ( [chrom, start, end, name, score, and strand](https://genome.ucsc.edu/FAQ/FAQformat.html) ) of CTCF-motifs under CTCF-ChIP peaks.
```{r CTCF}
CTCF = read.delim('/DATA/oidBackup/WAPL_Project/Hi-C/analysis/selected_regions/CTCF_WT_motifs.bed', h = F)
```

```{r, echo =F }
knitr::kable(
  head(CTCF, 5), caption = 'A data.frame holding a standard BED6 format.'
)
```

Moreover, we can use a bigwig (.bw) file to plot a track. For this example, we are using a SMC1 ChIP-seq track from [@Haarhuis2017]. We need the `bigwrig` package, which is easily installed:
```{r bigwrig, eval=F}
library(devtools)
install_github(repo ='bigwrig', username =  'jayhesselberth')
```

```{r HMPchip, message=FALSE , fig.cap= "Hi-C matrixplot: ChIPseq. A BED-file of CTCF-sites is plotted at the top and a coverage-track of SMC1 ChIP-seq is plotted to the left.",cache=T,fig.asp=1, dev = 'png', dpi=300,fig.small = F}

# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               chrom = 'chr7',
               start = 25e6,
               end=30e6, chip = list(CTCF,
                                     NULL,
                                     NULL, # outer-left
                                     'data/SMC1_WT.bw' ), # inner-left
               cut.off = 25) # upper limit of contacts
```

### Genes
We make use of the data.fame, where each row is an exon from a gene. There are several ways to get this. One of the easiest is to use biomart to get exon-coordinates. This can be done with the biomaRt-package or via the web-based service. For this example, we downloaded some data of all exons:
```{r biomart}
# Human genes (GRCh37.p13)
# Filters:
## With RefSeq mRNA ID(s): Only
# Attributes:
## Gene stable ID
## Transcript stable ID
## Chromosome/scaffold name
## Transcript start (bp)
## Transcript end (bp)
## Exon region start (bp)
## Exon region end (bp)
## Strand

martExport = read.delim('data/mart_export.txt.gz', stringsAsFactors = F)
colnames(martExport) = c('ENSG','ENST','chrom' , # change column names
                         'txStart' , 'txEnd' , 
                         'exonStart' , 'exonEnd' , 'strand')
martExport$chrom = gsub(martExport$chrom, # add chr-prefix
                        pattern = '^',
                        replacement = 'chr') 
martExport$strand = ifelse(martExport$strand == 1, '+',"-") # 1/-1 to +/-
```

```{r, echo =F }
knitr::kable(
  head(martExport[,-c(1,2)], 5), caption = 'A data.frame holding the needed columns.'
)
```

Now we can plot both the BED-file and the genes.
```{r HMPchipGene, message=FALSE , fig.cap= "Hi-C matrixplot: ChIPseq and genes. A BED-file of CTCF-sites is plotted below the genes.",cache=T,fig.asp=1, dev = 'png', dpi=300,fig.small = F}
# lets use a 5Mb-region on chromosome seven.
hic.matrixplot(exp1 = Hap1_WT_10kb,
               chrom = 'chr7',
               start = 25e6,
               end=30e6, 
               genes = martExport,
               chip = list(CTCF,
                           NULL,
                           NULL, # outer-left
                           NULL ), # inner-left
               cut.off = 25) # upper limit of contacts
```

# TADs
GENOVA has a large repetoire of functions to analyse TADs. We use the TAD-calls of WT Hap1 20-kb matrices from Haarhuis et al. [-@Haarhuis2017], generated with HiCseg [@Levy-Leduc2014].
```{r loadTAD, cache=T}
# Lets load in some TAD-annotations from HiC-seg
WT_TADs = read.delim('data/WT_hicseg_TADs.bed', h = F)
```

```{r fixTAD, echo = F, cache=T}
WT_TADs <-  WT_TADs[WT_TADs$V2 < WT_TADs$V3,]
```

```{r, echo =F }
knitr::kable(
  head(WT_TADs[,1:3], 5), caption = 'A data.frame holding a standard BED3 format.'
)
```

## ATA
```{r ATA, cache=T}
ATA_Hap1_WT   <- ATA(experiment = Hap1_WT_10kb,
                tad.bed = WT_TADs) 
ATA_Hap1_WAPL <-  ATA(experiment = Hap1_WAPL_10kb,
                 tad.bed = WT_TADs)
```

We can use `visualise.ATA.ggplot` to combine the ATA-results.

```{r ATAplot, message=FALSE , fig.cap= "ATA. In the WAPL-knockout, we see a decrease of contacts within the TAD, but an increase at the corner.",cache=T}
visualise.ATA.ggplot(stackedlist = list('WT' = ATA_Hap1_WT, 
                                        'WAPL' = ATA_Hap1_WAPL), # a named list
                     title = "Hap1 Hi-C vs WT TADs from HiCseg", 
                     zlim1 = c(0,75),
                     zlim2 = c(-5,5), 
                     focus = 1) # which entry to use as comparison
```

## TAD+N
```{r ii, cache=T}
TAD_N_WT   <- intra.inter.TAD.contacts(TAD = WT_TADs, 
                                       max.neighbor = 10, 
                                       exp = Hap1_WT_40kb)
TAD_N_WAPL <- intra.inter.TAD.contacts(TAD = WT_TADs, 
                                       max.neighbor = 10, 
                                       exp = Hap1_WAPL_40kb)
```

We can compute the enrichment of contacts between TADs with the `differential.TAD.dotplot`-function. 
```{r iiDIFF, message=FALSE , fig.cap= "Differential TAD-analysis. Experiment 2 (WAPL) has more interactions between neighbouring TADs",dev = 'png', dpi=300, cache=T, fig.retina=T}
differential.TAD.dotplot(exp1 = TAD_N_WT, # denominator
                         exp2 = TAD_N_WAPL) # numerator
```

# Loops
For this section, we are using the extended loops from Haarhuis et al. [-@Haarhuis2017]. These are the anchor-combinations of the merged loop-calls of WT Hap1 5-, 10- and 20-kb matrices, generated with HICCUPS [@Rao2014].
```{r loadLOOP, cache=T}
WT_Loops = read.delim('data/WT_3Mb_extended_loops.bed', h = F)
```

```{r fixLOOP, echo = F, cache=T}
WT_Loops$V1 = gsub(pattern = "^", replacement = "chr", x = WT_Loops$V1) 
WT_Loops$V4 = gsub(pattern = "^", replacement = "chr", x = WT_Loops$V4)

knitr::kable(
  head(WT_Loops[,1:6], 5), caption = 'A data.frame holding a standard BEDPE format.'
)
```


## APA
Explain smalltreshold
```{r APArun, cache=T}
APA_Hap1_WT   <- APA(experiment = Hap1_WT_10kb,
                     smallTreshold = 300e3,
                     loop.bed = WT_Loops)
APA_Hap1_WAPL <- APA(experiment = Hap1_WAPL_10kb,
                     smallTreshold = 300e3,
                     loop.bed = WT_Loops)
```


We can use `visualise.APA.ggplot` to combine the APA-results.
```{r APAplot, message=FALSE , fig.cap= "APA. In the WAPL-knockout, we see an increase of contacts at the loop.",cache=T, fig.retina=T}
visualise.APA.ggplot(APAlist = list('WT' = APA_Hap1_WT, 
                                    'WAPL' = APA_Hap1_WAPL), # a named list
                     title = "Hap1 Hi-C vs extended loops", 
                     zTop = c(1,12), # set the zlims of the upper row
                     zBottom = c(-8.33,8.33),
                     focus = 1) # which item in APAlist to use as comparison
```


## PE-SCAn

```{r SE1}
superEnhancers = read.delim('data/homerSuperEnhancers.txt', h = F, comment.char = "#")
```

```{r, echo =F }
knitr::kable(
  head(superEnhancers[,1:6], 5), caption = 'A data.frame holding the output `homer findPeaks -style super`.'
)
```

```{r PESCAn, message=FALSE , fig.cap= "PE-SCAn. There is a pairwise enrichment of contacts between Superenhancers, compared to shifted regions in both the WT and Wapl samples.",cache=T, fig.retina=T, fig.small = T}
WT_PE_OUT = PESCAn(exp = Hap1_WT_40kb, bed = superEnhancers[,2:4])
WAPL_PE_OUT = PESCAn(exp = Hap1_WAPL_40kb, bed = superEnhancers[,2:4])
visualise.PESCAn.ggplot(list(WT = WT_PE_OUT, WaplKO = WAPL_PE_OUT), resolution = 40e3, smooth = F)
```

Another way of looking at the PE-SCAn results, is to make a perspective plot. Here, the enrichment is encoded as the z-axis.

```{r pePERS, message=FALSE , fig.cap= "PE-SCAn perspective plots.",cache=T, fig.retina=T}
par(mfrow = c(1,2))
# get shared z-min and -max values
SHARED_Z = c(min(c(WT_PE_OUT, WAPL_PE_OUT)), 
               max(c(WT_PE_OUT, WAPL_PE_OUT)))
RES = 40e3 # resolution of the Hi-C

persp(list(x = seq(-1*(RES*10),(RES*10), length.out = 21)/1e6, # x-ticks (MB)
           y = seq(-1*(RES*10),(RES*10), length.out = 21)/1e6, # y-ticks (MB)
           z = WT_PE_OUT), # PE-SCAn out
      phi = 25, # colatitude 
      theta = 60, # rotation
      col="#92c5de", # color of the surface
      shade=0.4, # how much shading 
      xlab="", 
      ylab="", 
      zlab="",
      ticktype="detailed", 
      main="WT", 
      border=NA, 
      zlim = SHARED_Z)

persp(list(x = seq(-1*(RES*10),(RES*10), length.out = 21)/1e6, # x-ticks (MB)
           y = seq(-1*(RES*10),(RES*10), length.out = 21)/1e6, # y-ticks (MB)
           z = WAPL_PE_OUT), # PE-SCAn out
      phi = 25, # colatitude 
      theta = 60, # rotation
      col="#92c5de", # color of the surface
      shade=0.4, # how much shading 
      xlab="", 
      ylab="", 
      zlab="",
      ticktype="detailed", 
      main="WAPL", 
      border=NA, 
      zlim = SHARED_Z)
```

# To-do
For the next version, the following will be added/fixed:

- write `visualise.PESCAn.persp`

Please post questions, comments and rants on [our github issue tracker](https://github.com/robinweide/GENOVA/issues).

# Session info
```{r sesh, echo = F}
sessionInfo()
````

# References
```{r REF, echo = F, results = 'hide'}
sessionInfo()
````
